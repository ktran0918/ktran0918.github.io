{"pages":[],"posts":[{"title":"promisifying functions","text":"I can’t imagine what it was like before Promises were implemented in JavaScript, mostly because I didn’t start learning JavaScript until after ECMAScript 6 came out. The fact of the matter is Promises make it considerably easy to coordinate asynchronous calls. They also help with writing readable code. Consider the readFile() method from Node’s fs module. Without Promises one might use it like this: 123456const fs = require('fs');fs.readFile('example.txt', (err, data) =&gt; { if (err) console.error(err); console.log(data);}); Rather hard to read if you ask me. Imagine a scenario in which you might want to do more than printing to console, like sending that data to a client or parsing it for usable data. Or you may want to use it in a for loop, which is synchronous by nature. Worst case, you may want to call another asynchronous method later on, and thus end up with a callback within a callback. More of those and you enter “callback hell” (it’s a real term). Promises to the RescuePromises allow you to return a proxy value from an asynchronous function as you would with a synchronous one. That proxy value can later be resolved on success or rejected on failure. Therefore, Promises do not need callback functions. Any asynchronous method can be wrapped in a Promise, or “promisified”. Starting with Node v8, the built-in util module features a promisify() method for this purpose. Let’s use it on the readFile() example: 1234const fs = require('fs');const { promisify } = require('util');const readFile = promisify(fs.readFile); ES6 introduces the syntactic sugar await that makes writing Promises even better. Also, use it with try and catch for error handling: 12345678try { let data = readFile('example.txt'); // Do something else while waiting for readFile to resolve ... console.log(await data);} catch (err) { console.error(err);} Important: Remember that the keyword await can only be used in an async function! Next, learn how to use Promises efficiently.","link":"/2020/02/29/promisifying-functions/"},{"title":"Handling Blocking Awaits","text":"Promise, async, and await are nice. However, while they allow a developer to write asynchronous code in a synchronous style, one must avoid treating them in a synchronous way, thus overlooking the benefits of non-blocking JavaScript. Here’s an example: At my work, we deploy a couple of Node.js scripts for syncing computer entries in TeamDynamix (our IT management system) with those in SCCM and JAMF Pro (our device management system for Windows and Apple computers). Each script begins by pulling a relatively large amount of data from external databases and APIs, namely: List of all previously synced computer entries (we call them assets) from TeamDynamix List of all assets from SCCM or JAMF Pro, depending on the script List of all department entries List of all manufacturer entries Each of those calls can retrieve data independently of others. Ideally they should execute simultaneously in the background. How can we use await in a way that they don’t block each other? Solution: Promise.all()Below is a very close simplification of what we used to do: 123456789try { let syncedAssets = await getSyncedAssets(); let sccmAssets = await getSccmAssets(); let departments = await getDepartments(); let manufacturers = await getManufacturers();} catch (err) { console.error(err);} This was inefficient. You can see how each call must “await” on the previous one to resolve. This chain of blocking Promises unnecessary added to the total runtime. The solution: use Promise.all() to call and resolve all asynchronous calls at once. Promise.all() returns a single Promise that can be resolved when all of handled Promises are resolved, or rejected when any one is rejected. 12345678910111213141516171819try { // Promise.all() takes an iterable as argument let syncData = await Promise.all([ getSyncedAssets, getSccmAssets, getDepartments, getManufacturers ]); // When resolved, the Promise returns an iterable // containing individual data in the order of their respective calls let syncedAssets = syncData[0]; let sccmAssets = syncData[1]; let departments = syncData[2]; let manufacturers = syncData[3]; } catch (err) { console.error(err);} The resulting runtime is reduced to the runtime of whichever method takes the longest to resolve. Use await JudiciouslyIt’s important to remember that you don’t always need to await a Promise to resolve. await blocks code execution; it’s ideally used when the subsequent code relies on the resolved value from a Promise. If you don’t need a return value from an asynchronous call, consider dropping await so it is non-blocking. Let’s extend the example above. For debugging purposes we want to write SCCM assets to a file. The method writeFile() from the fs module doesn’t return any data when finished, so it doesn’t need an await: 123456789101112try { const fs = require('fs'); const { promisify } = require('util'); // Wrap fs.writeFile() in a Promise const writeFile = promisify(fs.writeFile); // Call writeFile without catching error writeFile('assets.json', syncedAssets); // with catching error (non-blocking) writeFile('assets.json', syncedAssets) .catch(err =&gt; console.error(err)); It’s subtle details like this that will improve the runtime of your JavaScript code!","link":"/2020/02/29/handling-blocking-awaits/"}],"tags":[{"name":"javascript, promises, async, await, node.js","slug":"javascript-promises-async-await-node-js","link":"/tags/javascript-promises-async-await-node-js/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}